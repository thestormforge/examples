apiVersion: apps.optimize.stormforge.io/v1alpha1
kind: Application
metadata:
  name: votingapp
# The resources identify where the manifests representing the application live.
# This is roughly the same as a Kustomize resources block, so you can use files,
# directories, URLs, Git repos, etc.
resources:
- https://github.com/thestormforge/examples/voting-webapp/application
# Control over the discovery of parameters, also optional
# The default is to generate patches for all deployments and stateful sets
# Here we decide to only optimize the voting service respon
parameters:
- containerResources:
    selector: component=voting-service
- replicas:
    selector: component=voting-service
# The host for the locust trial job
ingress:
  url: http://voting-service
# This section configures the scenarios of load generation
scenarios:
- name: 100-clients
  locust:
    locustfile: locustfile.py
    spawnRate: 20
    users: 100
# This section configures the objectives of optimization
# We want to minimize both cost and latency
objectives:
- goals:
  - name: cost-gcp # Also "cost", "cost-aws", "cpu", ...
  - name: p95-latency
    optimize: false
  - name: p99-latency
    max: 500
